/* This source file is part of the Tomviz project, https://tomviz.org/.
   It is released under the 3-Clause BSD License, see "LICENSE". */

#include "PtychoRunner.h"

#include "DataSource.h"
#include "LoadDataReaction.h"
#include "ProgressDialog.h"
#include "PtychoDialog.h"
#include "PythonUtilities.h"
#include "Utilities.h"

#include <QDebug>
#include <QDir>
#include <QFileInfo>
#include <QFutureWatcher>
#include <QMessageBox>
#include <QPointer>
#include <QtConcurrent>

namespace tomviz {

class PtychoRunner::Internal : public QObject
{
public:
  QPointer<PtychoRunner> parent;
  QPointer<QWidget> parentWidget;
  QPointer<PtychoDialog> ptychoDialog;
  QPointer<ProgressDialog> progressDialog;
  QFutureWatcher<bool> ptychoFutureWatcher;

  // Python modules and functions
  Python::Module ptychoModule;
  Python::Function stackPtychoFunc;

  // Ptycho options
  QString ptychoDirectory;
  QMap<QString, QStringList> loadSIDSettings;
  QString outputDirectory;
  bool rotateDatasets = true;

  // These will be generated by calling functions
  QStringList versionList;
  QList<long> sidList;
  QList<double> angleList;

  QStringList outputFiles;

  // Recon options
  QStringList selectedArrays;

  bool autoLoadFinalData = true;

  Internal(PtychoRunner* p) : parent(p)
  {
    setParent(p);
    parentWidget = mainWidget();

    progressDialog = new ProgressDialog(parentWidget);
    progressDialog->setWindowTitle("Tomviz");
    progressDialog->showOutputWidget(true);
    progressDialog->resize(progressDialog->width(), 500);

    setupConnections();
  }

  void setupConnections()
  {
    connect(&ptychoFutureWatcher, &QFutureWatcher<bool>::finished, this,
            &Internal::stackPtychoFinished);
  }

  void importModule()
  {
    Python python;

    if (ptychoModule.isValid()) {
      return;
    }

    ptychoModule = python.import("tomviz.ptycho");
    if (!ptychoModule.isValid()) {
      qCritical() << "Failed to import \"tomviz.ptycho\" module";
    }
  }

  bool isInstalled()
  {
    importModule();

    Python python;

    auto installed = ptychoModule.findFunction("installed");
    if (!installed.isValid()) {
      qCritical() << "Failed to import \"tomviz.ptycho.installed\"";
      return false;
    }

    auto res = installed.call();

    if (!res.isValid()) {
      qCritical() << "Error calling \"tomviz.ptycho.installed\"";
      return false;
    }

    return res.toBool();
  }

  bool onFailure(const QString& msg)
  {
    qCritical() << msg;
    QMessageBox::critical(parentWidget, "Tomviz", msg);
    return false;
  }

  QString importError()
  {
    importModule();

    Python python;

    auto func = ptychoModule.findFunction("import_error");
    if (!func.isValid()) {
      qCritical() << "Failed to import \"tomviz.ptycho.import_error\"";
      return "import_error not found";
    }

    auto res = func.call();

    if (!res.isValid()) {
      qCritical() << "Error calling \"tomviz.ptycho.import_error\"";
      return "import_error not found";
    }

    return res.toString();
  }

  void importFunctions()
  {
    importModule();

    Python python;

    if (!stackPtychoFunc.isValid()) {
      stackPtychoFunc = ptychoModule.findFunction("load_stack_ptycho");
      if (!stackPtychoFunc.isValid()) {
        qCritical() << "Failed to find function \"load_stack_ptycho\"";
      }
    }
  }

  template <typename T>
  void clearWidget(QPointer<T> d)
  {
    if (!d) {
      return;
    }

    d->hide();
    d->deleteLater();
    d.clear();
  }

  void clear()
  {
    clearWidget(ptychoDialog);
  }

  void start()
  {
    clear();
    importFunctions();
    showPtychoDialog();
  }

  void showPtychoDialog()
  {
    clearWidget(ptychoDialog);

    ptychoDialog = new PtychoDialog(parentWidget);
    connect(ptychoDialog.data(), &QDialog::accepted, this,
            &Internal::ptychoDialogAccepted);
    connect(ptychoDialog.data(), &PtychoDialog::needTableDataUpdate, this,
            &Internal::updatePtychoDialogTableData);
    ptychoDialog->show();
  }

  void updatePtychoDialogTableData()
  {
    if (!ptychoDialog) {
      return;
    }

    if (!QDir(ptychoDialog->ptychoDirectory()).exists()) {
      // Just ignore it, if the directory doesn't even exist
      ptychoDialog->clearTable();
      return;
    }

    Python python;

    auto func = ptychoModule.findFunction("gather_ptycho_info");
    if (!func.isValid()) {
      ptychoDialog->clearTable();
      QString msg = "Failed to import \"tomviz.ptycho.gather_ptycho_info\"";
      onFailure(msg);
      return;
    }

    Python::Dict kwargs;
    kwargs.set("ptycho_dir", ptychoDialog->ptychoDirectory());
    auto result = func.call(kwargs);

    if (!result.isValid() || !result.isDict()) {
      ptychoDialog->clearTable();
      QString msg = "Error calling \"tomviz.ptycho.gather_ptycho_info\"";
      onFailure(msg);
      return;
    }

    auto dict = result.toDict();
    auto min = dict["min_sid"].toVariant().toLong();
    auto max = dict["max_sid"].toVariant().toLong();
    auto versionListPy = dict["version_list"].toList();
    QStringList versionListStr;
    for (int i = 0; i < versionListPy.length(); ++i) {
      versionListStr.append(versionListPy[i].toString());
    }

    ptychoDialog->updateTableData(min, max, versionListStr);
  }

  void ptychoDialogAccepted()
  {
    // Gather the settings and decide what to do
    ptychoDirectory = ptychoDialog->ptychoDirectory();
    loadSIDSettings = ptychoDialog->loadSIDSettings();
    outputDirectory = ptychoDialog->outputDirectory();
    rotateDatasets = ptychoDialog->rotateDatasets();

    // Generate the stack ptycho input
    if (!generateStackPtychoInput()) {
      // An error message will have already appeared. Show the dialog
      // again and just return.
      showPtychoDialog();
      return;
    }

    runStackPtycho();
  }

  bool generateStackPtychoInput()
  {
    // Make these invalid if they were used before
    versionList.clear();
    sidList.clear();
    angleList.clear();

    // Call functions to generate the input required to stack ptycho results
    // Make sure the output directory exists
    if (!QDir().mkpath(outputDirectory)) {
      QString msg = "Failed to make output directory: " + outputDirectory;
      return onFailure(msg);
    }

    Python python;

    auto func = ptychoModule.findFunction("create_sid_list");
    if (!func.isValid()) {
      QString msg = "Failed to import \"tomviz.ptycho.create_sid_list\"";
      return onFailure(msg);
    }

    Python::Dict kwargs;
    kwargs.set("load_sid_settings", loadSIDSettingsAsPyObject());
    kwargs.set("ptycho_dir", ptychoDirectory);
    auto result = func.call(kwargs);

    if (!result.isValid() || !result.isDict()) {
      QString msg = "Error calling tomviz.ptycho.create_sid_list";
      return onFailure(msg);
    }

    auto outputDict = result.toDict();
    auto versionListPy = outputDict["version_list"];
    if (!versionListPy.isValid() || !versionListPy.isList()) {
      return onFailure("Invalid version_list from create_sid_list()");
    }

    auto sidListPy = outputDict["sid_list"];
    if (!sidListPy.isValid() || !sidListPy.isList()) {
      return onFailure("Invalid sid_list from create_sid_list()");
    }

    auto angleListPy = outputDict["angle_list"];
    if (!angleListPy.isValid() || !angleListPy.isList()) {
      return onFailure("Invalid angle_list from create_sid_list()");
    }

    // Now remove the invalid ones
    func = ptychoModule.findFunction("remove_sids_missing_data_or_angles");
    if (!func.isValid()) {
      QString msg = "Failed to import \"tomviz.ptycho.remove_sids_missing_data_or_angles\"";
      return onFailure(msg);
    }

    Python::Dict kwargs2;
    kwargs2.set("version_list", versionListPy);
    kwargs2.set("sid_list", sidListPy);
    kwargs2.set("angle_list", angleListPy);
    kwargs2.set("ptycho_dir", ptychoDirectory);

    // This function raises an exception if there are no versions or SIDs left
    // after removal. So check that the output is valid.
    if (!func.call(kwargs2).isValid()) {
      QString msg = "Error calling \"tomviz.ptycho.remove_sids_missing_data_or_angles\"";
      return onFailure(msg);
    }

    // Now set all of these on our basic type
    auto versionListPyList = versionListPy.toList();
    for (int i = 0; i < versionListPyList.length(); ++i) {
      versionList.append(versionListPyList[i].toString());
    }

    auto sidListPyList = sidListPy.toList();
    for (int i = 0; i < sidListPyList.length(); ++i) {
      sidList.append(sidListPyList[i].toLong());
    }

    auto angleListPyList = angleListPy.toList();
    for (int i = 0; i < angleListPyList.length(); ++i) {
      angleList.append(angleListPyList[i].toDouble());
    }

    return true;
  }

  Python::Dict loadSIDSettingsAsPyObject() const
  {
    Python python;

    Python::Dict ret;
    ret.set("version_list", loadSIDSettings["version_list"]);
    ret.set("load_methods", loadSIDSettings["load_methods"]);
    ret.set("load_sids", loadSIDSettings["load_sids"]);
    return ret;
  }

  void runStackPtycho()
  {
    progressDialog->clearOutputWidget();
    progressDialog->setText("Stacking ptychography datasets...");
    progressDialog->show();
    auto future = QtConcurrent::run(std::bind(&Internal::_runStackPtycho, this));
    ptychoFutureWatcher.setFuture(future);
  }

  bool _runStackPtycho()
  {
    Python python;

    // Reset the output files
    outputFiles.clear();

    if (!stackPtychoFunc.isValid()) {
      qCritical() << "Failed to find function \"load_stack_ptycho\"";
      return false;
    }

    Python::Dict kwargs;
    kwargs.set("version_list", versionList);
    kwargs.set("sid_list", sidList);
    kwargs.set("angle_list", angleList);
    kwargs.set("ptycho_dir", ptychoDirectory);
    kwargs.set("output_dir", outputDirectory);
    kwargs.set("rotate_datasets", rotateDatasets);
    auto result = stackPtychoFunc.call(kwargs);

    if (!result.isValid() || !result.isList()) {
      qCritical() << "Error calling tomviz.ptycho.load_stack_ptycho";
      return false;
    }

    auto resultList = result.toList();
    for (int i = 0; i < resultList.length(); ++i) {
      outputFiles.append(resultList[i].toString());
    }

    return true;
  }

  void stackPtychoFinished()
  {
    progressDialog->accept();

    auto success = ptychoFutureWatcher.result();
    if (!success || !validateResult()) {
      QString msg = "Stack ptycho failed";
      onFailure(msg);
      // Show the dialog again
      showPtychoDialog();
      return;
    }

    qDebug() << "Results written to:";
    for (const auto& filePath : outputFiles) {
      qDebug() << "  " << filePath;
    }

    if (autoLoadFinalData) {
      loadOutputFiles();
    }
  }

  bool validateResult() const
  {
    if (outputFiles.isEmpty()) {
      return false;
    }

    for (auto& filePath: outputFiles) {
      if (!QFile::exists(filePath)) {
        return false;
      }
    }

    return true;
  }

  void loadOutputFiles()
  {
    for (auto& filePath: outputFiles) {
      auto* dataSource = LoadDataReaction::loadData(filePath);
      if (!dataSource || !dataSource->imageData()) {
        qCritical() << "Failed to load file:" << filePath;
        return;
      }
    }

    QString title = "Loading ptycho data complete";
    auto text =
      QString("Ptycho data in \"%1\" was written and loaded into Tomviz")
        .arg(outputDirectory);
    QMessageBox::information(parentWidget, title, text);
  }
};

PtychoRunner::PtychoRunner(QObject* parent)
  : QObject(parent), m_internal(new Internal(this))
{
}

PtychoRunner::~PtychoRunner() = default;

bool PtychoRunner::isInstalled()
{
  return m_internal->isInstalled();
}

QString PtychoRunner::importError()
{
  return m_internal->importError();
}

void PtychoRunner::start()
{
  m_internal->start();
}

void PtychoRunner::setAutoLoadFinalData(bool b)
{
  m_internal->autoLoadFinalData = b;
}

} // namespace tomviz
